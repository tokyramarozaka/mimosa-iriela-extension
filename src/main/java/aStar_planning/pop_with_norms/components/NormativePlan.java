package aStar_planning.pop_with_norms.components;

import aStar.Operator;
import aStar.State;
import aStar_planning.pop.components.Flaw;
import aStar_planning.pop.components.OpenCondition;
import aStar_planning.pop.components.Plan;
import aStar_planning.pop.components.PlanElement;
import aStar_planning.pop.components.PlanModification;
import aStar_planning.pop.components.PopSituation;
import aStar_planning.pop.components.Step;
import aStar_planning.pop.components.Threat;
import aStar_planning.pop_with_norms.resolvers.MissingObligationResolver;
import aStar_planning.pop_with_norms.resolvers.MissingProhibitionResolver;
import constraints.CodenotationConstraints;
import constraints.TemporalConstraints;
import exception.UnapplicableNormException;
import logic.Action;
import logic.Atom;
import logic.Context;
import logic.ContextualAtom;
import logic.Term;
import lombok.Getter;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Getter
public class NormativePlan extends Plan {
    private final static Logger logger = LogManager.getLogger(NormativePlan.class);
    private final List<Organization> organizations;
    private final List<Role> roleKeywords;

    public NormativePlan(
            List<PopSituation> situations,
            List<Step> steps,
            CodenotationConstraints cc,
            TemporalConstraints tc,
            List<Organization> organizations
    ) {
        super(situations, steps, cc, tc, true);
        this.organizations = organizations;
        this.roleKeywords = getAllRoles();
        evaluateNormativeFlaws();
        addObligatoryPropositionsToGoals();
        super.evaluateFlaws();
    }

    private void addObligatoryPropositionsToGoals() {
        List<RegulativeNorm> obligationOnPropositions = getAllRegulativeNorms()
                .stream()
                .filter(norm -> norm.isObligation() && norm.enforceProposition())
                .toList();

        for (PopSituation situation : this.getSituations()) {
            for (RegulativeNorm obligation : obligationOnPropositions) {
                if (this.isApplicable(situation, obligation)) {
                    addNormativeGoal(obligation);
                }
            }
        }
    }

    private void addNormativeGoal(RegulativeNorm obligation) {
        Atom consequence = (Atom) obligation.getNormConsequences();
        List<Atom> existingPreconditions = this.getFinalStep().getActionPreconditions().getAtoms();

        if (!existingPreconditions.contains(consequence)) {
            logger.debug("Adding : " + obligation);
            existingPreconditions.add(consequence);
        }
    }

    /**
     * Adds to the flaw list all flaws related to regulative norms and the situation in which they
     * are not applied, namely :
     * <ul>
     *     <li>Missing obligations</li>
     *     <li>Missing prohibitions</li>
     * </ul>
     */
    public void evaluateNormativeFlaws() {
        List<RegulativeNorm> allRegulativeNorms = new ArrayList<>(getAllRegulativeNorms());
        List<RegulativeNorm> obligationsOnActions = getObligationsOnActions(allRegulativeNorms);
        List<RegulativeNorm> prohibitions = getProhibitions(allRegulativeNorms);

        // TODO: convert permissions to prohibitions and remove them
        // TODO : convert APPLICABLE obligations on propositions to goals and remove them;
        for (PopSituation situation : this.getSituations()) {
            List<RegulativeNorm> toEvaluate = getPotentialNormativeFlaws(obligationsOnActions, prohibitions);

            for (RegulativeNorm norm : toEvaluate) {
                if (isApplicable(situation, norm)) {
                    Context applicableContext = getApplicableContext(norm, situation);
                    this.addNormativeFlawsIfAny(situation, norm, applicableContext);
                }
            }
        }
    }

    /**
     * A helper function to concatenate obligations on actions and all prohibitions, including those
     * who have been generated by permissions. They are
     * the type of norms which can generate normative flaws in the plan.
     *
     * @param obligationsOnActions
     * @param prohibitions
     * @return
     */
    private List<RegulativeNorm> getPotentialNormativeFlaws(
            List<RegulativeNorm> obligationsOnActions,
            List<RegulativeNorm> prohibitions
    ) {
        List<RegulativeNorm> toEvaluate = new ArrayList<>();
        toEvaluate.addAll(obligationsOnActions);
        toEvaluate.addAll(prohibitions);
        toEvaluate.addAll(generatedProhibitionsFromPermissions(getAllRegulativeNorms()));

        return toEvaluate;
    }

    private List<RegulativeNorm> getProhibitions(List<RegulativeNorm> allRegulativeNorms) {
        return allRegulativeNorms
                .stream()
                .filter(RegulativeNorm::isProhibition)
                .collect(Collectors.toList());
    }

    private List<RegulativeNorm> getObligationsOnActions(List<RegulativeNorm> allRegulativeNorms) {
        return allRegulativeNorms
                .stream()
                .filter(norm -> norm.isObligation() && norm.enforceAction())
                .collect(Collectors.toList());
    }

    public List<RegulativeNorm> generatedProhibitionsFromPermissions(
            List<RegulativeNorm> allRegulativeNorms
    ) {
        List<RegulativeNorm> generatedProhibitions = new ArrayList<>();

        List<RegulativeNorm> permissionsOnPropositions = allRegulativeNorms
                .stream()
                .filter(norm -> norm.isPermission() && norm.enforceProposition())
                .toList();

        for (RegulativeNorm permission : permissionsOnPropositions) {
            this.getSituations().stream()
                    .filter(situation -> !this.isApplicable(situation, permission))
                    .forEach(insertProhibition(generatedProhibitions, permission));
        }

        return generatedProhibitions;
    }

    private Consumer<PopSituation> insertProhibition(
            List<RegulativeNorm> generatedProhibitions,
            RegulativeNorm permission
    ) {
        return situation -> generatedProhibitions.add(new RegulativeNorm(
                DeonticOperator.PROHIBITION,
                permission.getNormConditions(),
                permission.getNormConsequences()
        ));
    }

    private void addNormativeFlawsIfAny(
            PopSituation situation,
            RegulativeNorm norm,
            Context applicableContext
    ) {
        if (norm.isObligation() && norm.enforceAction()) {
            if (!actionIsPresentAsItShould(norm)) {
                addNormativeFlaw(situation, norm, applicableContext);
            }
        }
        if (norm.isProhibition()) {
//            TODO : add normative flaws to deal with prohibitions
//            if (norm.applicableWithin(getForbiddenInterval(situation, norm))) {
//                addNormativeFlaw(situation, norm, applicableContext);
//            }
        }
    }

    private Interval getForbiddenInterval(PopSituation startingSituation, RegulativeNorm norm) {
        // TODO : start from the situation, and then stop when you find an unapplicable situation
        return null;
    }

    private boolean actionIsPresentAsItShould(RegulativeNorm norm) {
        // TODO : check if inside the plan the mandatory action is there.
        return false;
    }

    /**
     * Adds a normative flaw to the set of flaws inside the plan. This happens when a regulative
     * norm is applicable but not applied as it should.
     *
     * @param situation is where the norm is applicable but not applied
     * @param norm      : the regulative norm concerned by the normative flaw
     */
    public void addNormativeFlaw(
            PopSituation situation,
            RegulativeNorm norm,
            Context applicableContext
    ) {
        this.getFlaws().add(new NormativeFlaw(
                this,
                norm,
                situation,
                applicableContext
        ));
    }

    /**
     * Adds all the actions from the set of institutions organized in this planning problem.
     * This searches through all active organizations and fetches actions attached to the role the
     * agent plays.
     *
     * @return a list of all possible actions based upon all active organizations.
     */
    public List<Action> getActionsFromAllInstitutions() {
        List<Action> possibleActions = new ArrayList<>();

        for (Organization organization : this.organizations) {
            possibleActions.addAll(organization.allActionsForAgent());
        }

        return possibleActions;
    }

    /**
     * Verifies if a norm is applicable by verifying all of its conditions, which demands
     * some constitutive norm, or some proposition to be necessarily true
     *
     * @param situation : the situation on which we want to check the norm's applicability
     *                  conditions
     * @param norm      : the norm whose applicability conditions will be tested.
     * @return true if the norm is applicable to the given situation, false otherwise.
     */
    public boolean isApplicable(PopSituation situation, RegulativeNorm norm) {
        Context conditionContext = new Context();
        Context normContext = new Context();

        for (Atom condition : norm.getNormConditions().getConditions()) {
            if (isRole(condition)) {
                if (!validatedByConstitutiveNorms(condition, conditionContext, normContext)) {
                    return false;
                }
            } else {
                if (!hasApplicableCodenotations(situation, norm)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Determines if an atom is a constitutive norm verification. Meaning that the atom requires
     * some constitutive norms, or else it is false.
     *
     * @param condition : the condition to check if it designates a role
     * @return true if the atom is referring to a constitutive norm, and false otherwise.
     */
    private boolean isRole(Atom condition) {
        return this.roleKeywords
                .stream()
                .anyMatch(role -> Objects.equals(
                        role.getName(),
                        condition.getPredicate().getName())
                );
    }

    /**
     * Checks if a condition matches with some constitutive norms of either the organization
     * or the institution
     *
     * @param condition : the proposition we want to verify as a constitutive norm
     * @return true if the condition is confirmed by some constitutive norm, and false otherwise
     */
    private boolean validatedByConstitutiveNorms(
            Atom condition,
            Context conditionContext,
            Context normContext
    ) {
        Term subject = condition.getPredicate().getTerms().get(0);
        String roleName = condition.getPredicate().getName();
        CodenotationConstraints ccCopy = this.getCc().copy();

        for (ConstitutiveNorm constitutiveNorm : this.getAllConstitutiveNorms()) {
            if ((roleName.equals(constitutiveNorm.getTarget().getName()))
                    && (subject.unify(
                    conditionContext,
                    constitutiveNorm.getSource(),
                    normContext,
                    ccCopy))
            ) {
                return !condition.isNegation();
            }
        }
        return condition.isNegation();
    }

    private boolean hasApplicableCodenotations(PopSituation situation, RegulativeNorm norm) {
        try {
            norm.getNormConditions().getApplicableCodenotations(this, situation);
            return true;
        } catch (UnapplicableNormException e) {
            return false;
        }
    }

    /**
     * Creates and inserts a new flaw in this plan's flaw set if the norm is not applied correctly
     *
     * @param situation      : the situation in which the norm ought to be applied
     * @param applicableNorm : the norm which ought to be applied.
     */
    private void createFlawIfNormNotApplied(PopSituation situation, RegulativeNorm applicableNorm) {
        Context applicableContext = getApplicableContext(applicableNorm, situation);

        if (!applicableNorm.isApplied(this, situation, this.getCc(), applicableContext)) {
            this.getFlaws().add(new NormativeFlaw(
                    this,
                    applicableNorm,
                    situation,
                    applicableContext
            ));
        }
    }

    /**
     * Solve a normative flaw depending on its deontic operator and consequence type (either a
     * proposition or an action that ought to be or not to be done).
     *
     * @param normativeFlaw   : the normative flaw to be solved
     * @param possibleActions : the set of all possible actions, necessary for solutions that
     *                        require adding in some new action, such as adding a mandatory
     *                        action.
     * @return a set of plan modifications that would solve the normative flaw.
     */
    public List<Operator> resolve(NormativeFlaw normativeFlaw, List<Action> possibleActions) {
        return switch (normativeFlaw.getFlawedNorm().getDeonticOperator()) {
            case OBLIGATION -> MissingObligationResolver.resolve(
                    this,
                    normativeFlaw,
                    possibleActions);
            case PROHIBITION -> MissingProhibitionResolver.resolve(this, normativeFlaw,
                    possibleActions);
            default -> throw new UnsupportedOperationException("Cannot resolve deontic operator" +
                    "in the normative flaw");
        };
    }

    public List<Action> getPermittedActions(
            PopSituation applicableSituation,
            List<Action> possibleActions
    ) {
        List<Action> permittedActions = new ArrayList<>(possibleActions);

        this.getAllRegulativeNorms()
                .stream()
                .filter(norm -> norm.isPermission() && norm.enforceAction())
                .filter(permission -> !isApplicable(applicableSituation, permission))
                .forEach(permission -> permittedActions.removeIf(
                        action -> action.equals(permission.getNormConsequences())
                ));

        return permittedActions;
    }

    private boolean isPermission(RegulativeNorm regulativeNorm) {
        return regulativeNorm.getDeonticOperator().equals(DeonticOperator.PERMISSION);
    }

    /**
     * Retrieves the context of application of a norm.
     * TODO : write the docs here for both obligations and prohibitions.
     *
     * @param norm
     * @param situation
     * @return
     */
    private Context getApplicableContext(RegulativeNorm norm, PopSituation situation) {
        if (norm.enforceProposition()) {
            Step followingStep = this.getTc().getFollowingStep(situation);
            return followingStep.getActionInstance().getContext();
        } else if (norm.enforceAction()) {
            Action forbiddenAction = ((NormativeAction) norm.getNormConsequences());

            Optional<Step> forbiddenStep = this.getSteps().stream()
                    .filter(step -> this.getTc().isBefore(situation, step))
                    .filter(step -> step.getActionInstance().getLogicalEntity()
                            .equals(forbiddenAction))
                    .findFirst();

            if (forbiddenStep.isPresent()) {
                return forbiddenStep.get().getActionInstance().getContext();
            }
        }
        throw new RuntimeException("Applicable context could not be found for : " + norm);
    }

    private List<RegulativeNorm> getAllRegulativeNorms() {
        List<RegulativeNorm> regulativeNorms = new ArrayList<>();

        for (Organization organization : this.organizations) {
            regulativeNorms.addAll(organization.getNorms().stream()
                    .filter(norm -> norm instanceof RegulativeNorm)
                    .map(norm -> (RegulativeNorm) norm)
                    .toList());
            regulativeNorms.addAll(organization.getInstitution().getNorms().stream()
                    .filter(norm -> norm instanceof RegulativeNorm)
                    .map(norm -> (RegulativeNorm) norm)
                    .toList());
        }

        return regulativeNorms;
    }

    private List<ConstitutiveNorm> getAllConstitutiveNorms() {
        List<ConstitutiveNorm> constitutiveNorms = new ArrayList<>();

        for (Organization organization : this.organizations) {
            constitutiveNorms.addAll(organization.getNorms().stream()
                    .filter(norm -> norm instanceof ConstitutiveNorm)
                    .map(norm -> (ConstitutiveNorm) norm)
                    .toList());
            constitutiveNorms.addAll(organization.getInstitution().getNorms().stream()
                    .filter(norm -> norm instanceof ConstitutiveNorm)
                    .map(norm -> (ConstitutiveNorm) norm)
                    .toList());
        }

        return constitutiveNorms;
    }

    /**
     * Returns all the asserted proposition in a given situation of the plan by retrieving all
     * preceding steps and their consequences
     *
     * @param situation : the situation where we want to retrieve all asserted propositions from
     * @return a list of propositions i.e. of ContextualAtoms which are
     */
    public List<ContextualAtom> getAllAssertedPropositions(
            PopSituation situation
    ) {
        List<ContextualAtom> assertedPropositions = new ArrayList<>();

        this.getSteps().stream().filter(step -> this.getTc().isBefore(step, situation))
                .forEach(precedingStep -> {
                    assertedPropositions.addAll(getRemainingPropositions(precedingStep, situation));
                });

        return assertedPropositions;
    }

    private List<ContextualAtom> getRemainingPropositions(
            Step precedingStep,
            PopSituation situation
    ) {
        List<ContextualAtom> remainingPropositions = new ArrayList<>();

        precedingStep.getActionConsequences().getAtoms().forEach(consequence -> {
            ContextualAtom toAdd = new ContextualAtom(
                    precedingStep.getActionInstance().getContext(), consequence
            );

            if (precedingStep.asserts(toAdd, this.getCc())) {
                List<Step> destroyers = this.getSteps().stream()
                        .filter(step -> step.destroys(toAdd, this.getCc()))
                        .filter(destroyer -> isBetween(precedingStep, destroyer, situation))
                        .toList();

                if (destroyers.isEmpty()) {
                    remainingPropositions.add(toAdd);
                }

                for (Step destroyer : destroyers) {
                    if (this.isRestablished(toAdd, destroyer, situation)) {
                        remainingPropositions.add(toAdd);
                    }
                }
            }
        });

        return remainingPropositions;
    }

    /**
     * Checks if some element in the plan is between two others. Namely, checks if the target
     * element is between the start and the finish element.
     *
     * @param start   : the element at the left edge of the interval we want to check
     * @param target: the element we want to check if it is between start and finish
     * @param finish: the element at the right edge of the interval we want to check
     * @return true if start < target < finish, and false otherwise.
     */
    private boolean isBetween(PlanElement start, PlanElement target, PlanElement finish) {
        return this.getTc().isBefore(start, target) && this.getTc().isBefore(target, finish);
    }

    private List<Role> getAllRoles() {
        List<Role> roles = new ArrayList<>();

        for (Organization organization : this.organizations) {
            List<Role> rolesFromInstitution = organization.getInstitution().getConcepts()
                    .stream()
                    .filter(concept -> concept.getClass() == Role.class)
                    .map(constant -> (Role) constant)
                    .toList();

            roles.addAll(rolesFromInstitution);
        }

        return roles;
    }

    @Override
    public State applyPlanModification(Operator toApply) {
        return ((PlanModification) toApply).apply(this);
    }

    @Override
    public List<Operator> resolve(Flaw toSolve, List<Action> possibleActions) {
        List<Action> permittedActions = getPermittedActions(
                toSolve.getApplicableSituation(),
                possibleActions
        );

        if (toSolve instanceof OpenCondition) {
            return resolve((OpenCondition) toSolve, permittedActions);
        } else if (toSolve instanceof Threat) {
            return resolve((Threat) toSolve);
        } else if (toSolve instanceof NormativeFlaw) {
            return resolve((NormativeFlaw) toSolve, permittedActions);
        }

        throw new UnsupportedOperationException("Flaw type not supported yet.");
    }

    @Override
    protected List<Flaw> getOpenConditions(Step step) {
        List<Flaw> openConditions = new ArrayList<>();
        List<Atom> stepPreconditions = step.getActionPreconditions().getAtoms();
        CodenotationConstraints temporaryCc = new CodenotationConstraints(new ArrayList<>(
                this.getCc().getCodenotations())
        );

        for (Atom precondition : stepPreconditions) {
            if (isRole(precondition)) {
                if (validatedByConstitutiveNorms(precondition, step.getActionInstance().getContext(),
                        new Context())
                ) {
                    // you might consider completing this code to account for constitutive norms
                    continue;
                }
            } else {
                ContextualAtom preconditionInstance = new ContextualAtom(
                        step.getActionInstance().getContext(), precondition
                );

                if (!isAsserted(preconditionInstance, this.getTc().getPrecedingSituation(step),
                        temporaryCc)) {
                    openConditions.add(buildOpenCondition(precondition, step));
                }
            }
        }

        return openConditions;
    }

    @Override
    public String toString() {
        return super.toString() +
                "\n-- ORGANIZATIONS : \n\t" +
                this.organizations;
    }
}
