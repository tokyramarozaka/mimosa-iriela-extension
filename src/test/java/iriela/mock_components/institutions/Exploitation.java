package iriela.mock_components.institutions;

import aStar_planning.pop_with_norms.components.DeonticOperator;
import aStar_planning.pop_with_norms.components.Institution;
import aStar_planning.pop_with_norms.components.Norm;
import aStar_planning.pop_with_norms.components.NormConditions;
import aStar_planning.pop_with_norms.components.NormConsequences;
import aStar_planning.pop_with_norms.components.NormativeAction;
import aStar_planning.pop_with_norms.components.NormativeProposition;
import aStar_planning.pop_with_norms.components.RegulativeNorm;
import aStar_planning.pop_with_norms.components.Role;
import aStar_planning.pop_with_norms.concepts.ActionName;
import iriela.mock_components.TermsFactory;
import logic.Action;
import logic.ActionConsequence;
import logic.ActionPrecondition;
import logic.Atom;
import logic.Constant;
import logic.Predicate;
import logic.Term;

import java.util.ArrayList;
import java.util.List;

public class Exploitation {
    // CONCEPTS
    public static Role farmer = new Role("farmer");
    public static ActionName getLicense = new ActionName("getLicense");

    // ASSERTIONS
    public static Predicate hasLicense(Term object){
        return new Predicate("hasLicense", List.of(object));
    }

    // ACTIONS
    public static ActionPrecondition getLicensePreconditions(Term subject, Term zone) {
        return new ActionPrecondition(List.of(
                new Atom(false, Exploitation.farmer(subject)),
                new Atom(false, Global.zone(zone)),
                new Atom(false, Global.located(subject, zone)),
                new Atom(false, Village.office(zone))
        ));
    }

    public static ActionConsequence getLicenseConsequences(Term subject) {
        return new ActionConsequence(new ArrayList<>(List.of(
                new Atom(false, Exploitation.hasLicense(subject))
        )));
    }

    public static Action getLicense(Term subject, Term zone) {
        return new Action(
                Exploitation.getLicense,
                getLicensePreconditions(subject, zone),
                getLicenseConsequences(subject)
        );
    }

    // NORMS
    public static List<Norm> norms(){
        return List.of(
                licenseObligation(TermsFactory.X),
                cutPermission(TermsFactory.X, TermsFactory.Z),
                fishPermission(TermsFactory.X, TermsFactory.Z)
        );
    }
    private static Norm licenseObligation(Term subject) {
        return new RegulativeNorm(
                DeonticOperator.OBLIGATION,
                conditionsLicenseObligation(subject),
                consequencesLicenseObligation(subject)
        );
    }

    private static NormConsequences consequencesLicenseObligation(Term subject) {
        return new NormativeProposition(false,Exploitation.hasLicense(subject));
    }

    private static NormConditions conditionsLicenseObligation(Term subject) {
        return new NormConditions(List.of(
                new Atom(false, Exploitation.farmer(subject))
        ));
    }

    private static Norm fishPermission(Term subject, Term zone) {
        return new RegulativeNorm(
                DeonticOperator.PERMISSION,
                conditionsFishPermission(subject, zone),
                consequencesFishPermission(subject, zone)
        );
    }

    private static Norm cutPermission(Term subject, Term zone){
        return new RegulativeNorm(
                DeonticOperator.PERMISSION,
                conditionsCutPermission(subject, zone),
                consequencesCutPermission(subject, zone)
        );
    }
    private static NormConditions conditionsCutPermission(Term subject, Term zone) {
        return new NormConditions(List.of(
                new Atom(false, Exploitation.farmer(subject)),
                new Atom(false, Global.zone(zone)),
                new Atom(false, Global.located(subject,zone)),
                new Atom(false, Village._protected(zone)),
                new Atom(false, Exploitation.hasLicense(subject))
        ));
    }
    private static NormConsequences consequencesCutPermission(Term subject, Term zone) {
        return new NormativeAction(Village.cut(subject, zone));
    }

    private static NormConditions conditionsFishPermission(Term subject, Term zone) {
        return new NormConditions(List.of(
                new Atom(false, Exploitation.farmer(subject)),
                new Atom(false, Global.located(subject, zone)),
                new Atom(false, Village._protected(zone)),
                new Atom(false, Exploitation.hasLicense(subject))
        ));
    }

    private static NormConsequences consequencesFishPermission(Term subject, Term zone) {
        return new NormativeAction(Village.fish(subject, zone));
    }

    // INSTITUTION
    public static Institution get(){
        return new Institution(
                "exploitation",
                8,
                Exploitation.concepts(),
                Exploitation.assertions(),
                Exploitation.actions(),
                Exploitation.norms()
        );
    }

    // ROLE CHECK PREDICATES
    public static Predicate farmer(Term subject){
        return new Predicate("farmer", List.of(subject));
    }

    private static List<Constant> concepts() {
        return List.of(farmer, getLicense);
    }

    private static List<Predicate> assertions() {
        return List.of(
            hasLicense(TermsFactory.X)
        );
    }

    private static List<Action> actions() {
        return List.of(
                getLicense(TermsFactory.X, TermsFactory.Z)
        );
    }
}
